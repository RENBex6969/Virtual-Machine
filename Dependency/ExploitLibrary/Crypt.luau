local Base64 = require("./Base64")
local Serde = require("@lune/serde")

local bit = bit32 or bit
local function Xor(Text, Key)
	local Compiled = {}
	for i = 1, #Text do
		Compiled[i] = string.char(bit.bxor(Text:byte(i), Key:byte(((i - 1) % #Key) + 1)))
	end
	return table.concat(Compiled)
end

local CompiledBase64 = {
  encode = function(String)
    if type(String) ~= "string" or String == nil then
      return ""
    end
    return Base64.encode(String)
  end,
  decode = function(String)
    if type(String) ~= "string" or String == nil then
      return ""
    end
    return Base64.decode(String)
  end
}

local Crypt; Crypt = {
  base64 = CompiledBase64,
  base64encode = CompiledBase64.encode,
  base64decode = CompiledBase64.decode,
  base64_encode = CompiledBase64.encode,
  base64_decode = CompiledBase64.decode,
  random = function(Size)
    local Size = Size or 32
    local Final = ""
    for i = 1, Size do
      Final = Final .. tostring(math.random(1, 9))
    end
    return Final
  end,
  generatebytes = function(size)
    local size = size or 16
    local bytes = {}
    for i = 1, size do
      bytes[i] = string.char(math.random(0, 255))
    end
    local raw = table.concat(bytes)
    return Crypt.base64.encode(raw)
  end,
  generatekey = function()
    return Crypt.generatebytes(32)
  end,
  hash = function(Message, Algroithim)
    if type(Message) ~= "string" or Message == nil then
      return false
    end
    return Serde.hash(Algroithim, Message)
  end,
  encrypt = function(PlainText, Key, IV)
    local BlockSize = #Key
    local IV = IV or string.rep("\0", BlockSize)
    local Encrypted, Previous = {}, IV
    for i = 1, #PlainText, BlockSize do
      local Block = PlainText:sub(i, i + BlockSize - 1)
      if #Block < BlockSize then
        Block = Block .. string.rep("\0", BlockSize - #Block)
      end
      local Xored = Xor(Block, Previous)
      local CipherBlock = Xor(Xored, Key)
      table.insert(Encrypted, CipherBlock)
      Previous = CipherBlock
    end
    return table.concat(Encrypted), IV
  end,
  decrypt = function(CipherText, Key, IV)
    assert(IV, "IV must be provided (either from caller or from encryptâ€™s return)")
    local BlockSize = #Key
    local Decrypted, Previous = {}, IV
    for i = 1, #CipherText, BlockSize do
        local Block = CipherText:sub(i, i + BlockSize - 1)
        local Xored = Xor(Block, Key)
        local PlainBlock = Xor(Xored, Previous)
        table.insert(Decrypted, PlainBlock)
        Previous = Block
    end
    return (table.concat(Decrypted):gsub("%z+$", ""))
  end
}

return Crypt