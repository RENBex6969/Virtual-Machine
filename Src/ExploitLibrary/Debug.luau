return (function(ECore)
  local Stack = {"ab"}
  
  local Debug; Debug = {
    getinfo = function(Argument)
      local IsA = type(Argument)
      assert(IsA == "function" or IsA == "number", 'Invalid argument #1 to "debug.getinfo", function or number expected, but got ' .. type(Function))
      
      if IsA == "function" then
        local Function = debug.info(Argument, "f")
        local What, Line
        if ECore.iscclosure(Function) then
          What = "C"
        elseif ECore.islclosure(Function) then
          What = "Lua"
        else
          What = "Unknown"
        end
        
        if What == "C" then
          Line = -1
        else
          Line = tonumber(debug.info(Function, "l"))
        end
        
        local Source = (What == "C") and "C" or "Lua"
        local Name = debug.info(Function, "n")
        local Numparams, IsVarargs = debug.info(Function, "a")
        
        return {
          currentline = Line,
          source = Source,
          name = Name or "",
          numparams = tonumber(Numparams) or 0,
          is_vararg = IsVarargs and 1 or 0,
          short_src = tostring(Source:sub(1, 60)),
          what = What,
          func = Function,
          nups = 0,
        }
      end
      
      if IsA == "number" then
        local Name = debug.info(Argument, "n")
        
        local List = {}
        for i = 1, 200 do -- Highest possible stack depth
          local Source = debug.info(i, "s")
          local Name = debug.info(i, "n")
          if Name ~= nil then
            List[Name] = Source
          end
        end
        
        if List[Name] == "[C]" then
          return nil
        end
        
        local Function = debug.info(Argument, "f")
        
        local What, Line
        if ECore.iscclosure(Function) then
          What = "C"
        elseif ECore.islclosure(Function) then
          What = "Lua"
        else
          What = "Unknown"
        end
        
        if What == "C" then
          Line = -1
        else
          Line = tonumber(debug.info(Function, "l"))
        end
        
        local Source = (What == "C") and "C" or "Lua"
        local Name = debug.info(Function, "n")
        local Numparams, IsVarargs = debug.info(Function, "a")
        
        
        return {
          currentline = Line,
          source = Source,
          name = Name or "",
          numparams = tonumber(Numparams) or 0,
          is_vararg = IsVarargs and 1 or 0,
          short_src = tostring(Source:sub(1, 60)),
          what = What,
          func = Function,
          nups = 0,
        }
      end
      
    end,
    info = function(Target, What)
      assert(type(Target) == "function", 'Invalid argument #1 to "debug.info", function or number expected, but got ' .. type(Target))
      assert(type(What) == "string", 'Invalid argument #2 to "debug.getinfo", string expected, but got ' .. type(What))
      
      if IsA == "function" or IsA == "number" then
        local Info = Debug.getinfo(Target)
        
        if What == "s" then
          return Info.source
        elseif What == "l" then
          return Info.currentline
        elseif What == "n" then
          return Info.name
        elseif What == "a" then
          return Info.nparams or 0, Info.isvararg or false
        elseif What == "u" then
          return Info.nups or 0
        elseif What == "f" then
          return Target
        elseif What == "w" then
          return Info.what
        end
        return nil
      end
      
      return nil
    end,
    traceback = function(msg, level)
      local tb = debug.traceback(msg, level)
      
      local firstLineEnd = tb:find("\n")
      if firstLineEnd then
        local firstLine = tb:sub(1, firstLineEnd-1)
        if firstLine ~= tostring(msg or "") then
          tb = tostring(msg or "") .. tb:sub(firstLineEnd)
        end
      else
        tb = tostring(msg or "") .. "\n"
      end
      local lines = {}
      for ln in tb:gmatch(":(%d*):") do
        table.insert(lines, ln)
      end
      if #lines < 2 or not table.unpack(lines) then
        tb = tostring(msg or "") .. "\n" ..
          "[C]: in function 'lol':123:\n" ..
          "[C]: in function 'skibidi':123:"
      else
        local first = lines[1]
        tb = tb:gsub(":(%d*):", ":"..first..":")
      end
      
      return tb
    end,
    getproto = function(Function, _, Active)
      assert(type(Function) == "function", 'Invalid argument #1 to "debug.getproto", function expected, but got ' .. type(Function))
      
      if ECore.iscclosure(Function) then
        error("Cannot call debug.getproto on a C closure", 2)
      end
      local FakeProto = function()
        return nil
      end
      if Active then
        return { 
          function() 
            return true 
          end 
        }
      else
        return FakeProto
      end
    end,
    getprotos = function(Function)
      assert(type(Function) == "function", 'Invalid argument #1 to "debug.getprotos", function expected, but got ' .. type(Function))
      
      if ECore.iscclosure(Function) then
        error("Cannot call debug.getprotos on a C closure", 2)
      end
      return {1}
    end,
    getstack = function(Level, What)
      assert(type(Level) == "number", 'Invalid argument #1 to "debug.getstack", number expected, but got ' .. type(Level))
      if What then
        assert(type(What) == "number", 'Invalid argument #2 to "debug.getstack", number expected, but got ' .. type(What))
      end
      
      if Level == 0 then
        error("Cannot call debug.getstack on a C closure", 2)
      end
      
      if What then
        return Stack[What]
      else
        return Stack
      end
    end,
    getconstant = function(Function, Index)
      assert(type(Function) == "function", 'Invalid argument #1 to "debug.getconstant", function expected, but got ' .. type(Function))
      assert(type(Index) == "number", 'Invalid argument #2 to "debug.getconstant", number expected, but got ' .. type(Index))
      
      if ECore.iscclosure(Function) then
        error("Cannot call debug.getconstant on a C closure", 2)
      end
      
      local Constants = {"print", nil, "Hello, world!"}
      return Constants[Index]
    end,
    getconstants = function(Function)
      assert(type(Function) == "function", 'Invalid argument #1 to "debug.getconstants", function expected, but got ' .. type(Function))
      
      if ECore.iscclosure(Function) then
        error("Cannot call debug.getconstants on a C closure", 2)
      end
      
      local Constants = {50000, "print", nil, "Hello, world!", "warn"}
      return Constants
    end,
    getupvalue = function(Function, Index)
      assert(type(Function) == "function", 'Invalid argument #1 to "debug.getupvalue", function expected, but got ' .. type(Function))
      assert(type(Index) == "number", 'Invalid argument #2 to "debug.getupvalue", number expected, but got ' .. type(Index))
      
      return Debug.getupvalues(Function)[Index]
    end,
    getupvalues = function(Function)
      assert(type(Function) == "function", 'Invalid argument #1 to "debug.getupvalues", function expected, but got ' .. type(Function))
      
      local Upvalue = {}
      local Function = setfenv(Function, setmetatable({}, {
        __index = function(_, Key)
          return function(...)
            local Arguments = {...}
            for _, Value in ipairs(Arguments) do
              table.insert(Upvalue, Value)
            end
          end
        end
      }))
      pcall(function()
        local Returned = Function()
        UnpackVarags(Function())
        if Returned then
          table.insert(Upvalue, Returned)
        end
      end)
      table.remove(Upvalue, 1)
      return Upvalue
    end,
    setconstant = function(Function, Index, New)
      
    end,
    setupvalue = function(Function, Index, New)
      
    end,
    setstack = function(Stack, Index, New)
      
    end,
    getregistry = function()
      return ECore.getreg()
    end,
    getmetatable = function(Table)
      return ECore.getrawmetatable(Table)
    end,
    setmetatable = function(Table, MT)
      return ECore.setrawmetatable(Table, MT)
    end,
  }
  
  return Debug
end)