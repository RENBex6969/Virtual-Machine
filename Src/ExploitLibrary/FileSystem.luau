local FileSystem = require("@lune/fs")
local Regex = require("@lune/regex")
local Serde = require("@lune/serde")

local Workspace, Library, Debug = "./Workspace/", {}, true
assert(FileSystem.isDir("Workspace"), "Workspace folder is missing from the root directory!")

assert(FileSystem.isFile("config.json"), "Default config.json is missing from the root directory!")
local ConfigJSON = FileSystem.readFile("config.json")

local Config = Serde.decode("json", ConfigJSON)

local MaxFileSize = Config.FileSystem.MaxFileSize

local function Sanitize(Path : string): string
  assert(type(Path) == "string", "Sanitize: Expected string")

  if Path:sub(1, #Workspace) == Workspace then
    return Path
  end

  local ReSplit = Regex.new("/")
  local Segments = ReSplit:split(Path)

  local SafeSegments = {}
  for _, Segment in ipairs(Segments) do
    if Segment ~= "." and Segment ~= ".." and Segment ~= "" then
      table.insert(SafeSegments, Segment)
    end
  end

  return Workspace .. table.concat(SafeSegments, "/")
end

local function ensurePathExists(Path : string): ()
  assert(type(Path) == "string", "ensurePathExists: Expected argument #1 to be a string")
  local Sanitized = Sanitize(Path)

  local ReSplit = Regex.new("/")
  local Segments = ReSplit:split(Sanitized)

  table.remove(Segments)

  local Current = ""

  for _, Segment in ipairs(Segments) do
    if Segment ~= "" then
      Current ..= Segment .. "/"
      
      local IsDir = FileSystem.isDir(Current)
      if not IsDir then
        local Succ = pcall(FileSystem.writeDir, Current)
        assert(Succ, "ensurePathExists: failed to create folder '" .. Current .. "'")
      end
    end
  end
end

function Library.appendfile(Path : string, Content : string): ()
  assert(type(Path) == "string", "appendfile: Expected argument #1 to be a string, got " .. type(Path))
  local Type = type(Content)
  assert(Type == "string" or Type == "number" or Type == "boolean", "appendfile: Expected argument #2 to be a string, number, or boolean, got " .. Type)
  
  assert(#tostring(Content) <= tonumber(MaxFileSize), "appendfile: exceeds limit of " .. (tonumber(MaxFileSize) / 1024 / 1024) .. " MB")
  local SanitizedPath = Sanitize(Path)
  
  assert(not FileSystem.isDir(SanitizedPath), "appendfile: Expected argument #1 to be a file path, got folder path")
  
  local Succ, Output = pcall(FileSystem.readFile, SanitizedPath)
  assert(Succ, "Error occured on appendfile (1)")
  
  Output ..= Content
  
  local Succ, _ = pcall(FileSystem.writeFile, SanitizedPath, Output)
  assert(Succ, "Error occured on appendfile (2)")
end

function Library.delfile(Path: string): ()
  assert(type(Path) == "string", "delfile: Expected argument #1 to be a string, got " .. type(Path))
  local SanitizedPath = Sanitize(Path)
  
  local Succ, _ = pcall(FileSystem.removeFile, SanitizedPath)
  
  assert(Succ, "Error occured on delfile")
end

function Library.delfolder(Path: string): ()
  assert(type(Path) == "string", "delfolder: Expected argument #1 to be a string, got " .. type(Path))
  local SanitizedPath = Sanitize(Path)
  
  local Succ, _ = pcall(FileSystem.removeDir, SanitizedPath)
  
  assert(Succ, "Error occured on delfolder")
end

function Library.isfile(Path: string): boolean
  assert(type(Path) == "string", "isfile: Expected argument #1 to be a string, got " .. type(Path))
  local SanitizedPath = Sanitize(Path)
  
  local Succ, Output = pcall(FileSystem.isFile, SanitizedPath)
  
  assert(Succ, "Error occured on isfile")
  return Output
end

function Library.isfolder(Path: string): boolean
  assert(type(Path) == "string", "delfile: Expected argument #1 to be a string, got " .. type(Path))
  local SanitizedPath = Sanitize(Path)
  local Succ, Output = pcall(FileSystem.isDir, SanitizedPath)
  
  assert(Succ, "Error occured on isfolder")
  return Output
end

function Library.listfiles(Path: String): { string }
  assert(type(Path) == "string", "listfiles: Expected argument #1 to be a string, got " .. type(Path))
  local SanitizedPath = Sanitize(Path)
  
  local Succ, isDir = pcall(FileSystem.isDir, SanitizedPath)
  assert(Succ or isDir, "listfiles: Expected argument #2 to be a folder path, got file")
  
  local Succ, Files = pcall(FileSystem.readDir, SanitizedPath)
  assert(Succ or Files, "listfiles: failed to read directory")
  
  local Out = table.create(#Files)
  for i, Value in ipairs(Files) do
    Out[i] = SanitizedPath .. "/" .. Value
  end
  
  return Out
end

function Library.makefolder(Path: string): ()
  assert(type(Path) == "string", "makefolder: Expected argument #1 to be a string, got " .. type(Path))
  local SanitizedPath = Sanitize(Path)
  
  local Succ, _ = pcall(FileSystem.writeDir, SanitizedPath)
  assert(Succ, "Error occured on makefolder")
end

function Library.readfile(Path: string): string
  assert(type(Path) == "string", "writefile: Expected argument #1 to be a string, got " .. type(Path))
  
  local SanitizedPath = Sanitize(Path)
  local Succ, Output = pcall(FileSystem.readFile, SanitizedPath)
  
  assert(Succ, "Error occured on readfile")
  return Output
end

function Library.writefile(Path : string, Content : string): ()
  assert(type(Path) == "string", "writefile: Expected argument #1 to be a string, got " .. type(Path))
  local Type = type(Content)
  assert(Type == "string" or Type == "number" or Type == "boolean", "writefile: Expected argument #2 to be a string, number, or boolean, got " .. Type)
  
  assert(#tostring(Content) <= tonumber(MaxFileSize), "writefile: exceeds limit of " .. (tonumber(MaxFileSize) / 1024 / 1024) .. " MB")
  
  local SanitizedPath = Sanitize(Path)
  local Succ, _ = pcall(ensurePathExists, Path)
  assert(Succ, "Error occured on writefile")
  
  local Succ, _ = pcall(FileSystem.writeFile, SanitizedPath, Content)
  assert(Succ, "Error occured on writefile")
end

return Library