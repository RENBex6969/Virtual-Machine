local FileSystem = require("@lune/fs")
local Serde = require("@lune/serde")
local Random = require("@Dep/random")
local Base64 = require("./base64")
local Encode = Base64.encode
local Decode = Base64.decode
local Library = {}

local function Xor(Text : string, Key : string): string
  local Out = table.create(#Text)
  for i = 1, #Text do
    local StringByte, KeyByte = Text:byte(i), Key:byte( ((i - 1) % #Key) + 1)
    Out[i] = string.char(bit32.bxor(StringByte, KeyByte))
  end
  return table.concat(Out)
end

local function Pad(Text : string, BlockSize : number): string
  local PadLength = BlockSize - (#Text % BlockSize)
  return Text .. string.rep(string.char(PadLength), PadLength)
end

local function Unpad(Text : string): string
  local PadLength = string.byte(Text:sub(-1))
  assert(PadLength > 0 and PadLength <= #Text, "Invalid padding")
  
  return Text:sub(1, #Text - PadLength)
end

Library.base64 = {}
function Library.base64.encode(Text : string): string
  assert(type(Text) == "string", "crypt.base64.encode: expected argument #1 to be a string, got " .. type(Text))
  return Encode(Text)
end

function Library.base64.decode(Text : string): string
  assert(type(Text) == "string", "crypt.base64.decode: expected argument #1 to be a string, got " .. type(Text))
  return Decode(Text)
end

function Library.base64encode(Text : string): string
  assert(type(Text) == "string", "crypt.base64encode: expected argument #1 to be a string, got " .. type(Text))
  return Encode(Text)
end

function Library.base64decode(Text : string): string
  assert(type(Text) == "string", "crypt.base64decode: expected argument #1 to be a string, got " .. type(Text))
  return Decode(Text)
end

function Library.base64_encode(Text : string): string
  assert(type(Text) == "string", "crypt.base64_encode: expected argument #1 to be a string, got " .. type(Text))
  return Encode(Text)
end

function Library.base64_decode(Text : string): string
  assert(type(Text) == "string", "crypt.base64_decode: expected argument #1 to be a string, got " .. type(Text))
  return Decode(Text)
end

function Library.random(Length: number?): string
  assert(Length == nil or type(Length) == "number", "crypt.random: expected argument #1 to be a number or nil, got " .. type(Length))
  Length = Length or 32
  assert(Length > 0 and Length < 1024, "crypt.random: expected argument #1 to be greater than 0 and less than 1024, got " .. Length)
  
  return Random:string(Length)
end

function Library.generatebytes(Length: number?): string
  assert(Length == nil or type(Length) == "number", "crypt.generatebytes: expected argument #1 to be a number or nil, got " .. type(Length))
  Length = Length or 16
  
  local Bytes = table.create(Length)
  for i = 1, Length do
    Bytes[i] = string.char(math.random(1, 255))
  end
  
  return Encode(table.concat(Bytes))
end

function Library.generatekey(Value: string?): string
  assert(Value == nil or type(Value) == "string", "crypt.generatekey: expected argument #1 to be a string, got " .. type(Value))
  
  local Bytes = table.create(32)
  for i = 1, 32 do
    Bytes[i] = string.char(math.random(0, 255))
  end
  
  return Encode(table.concat(Bytes))
end

function Library.derive(Value: string, Length: number): string
  assert(type(Value) == "string", "crypt.derive: expected argument #1 to be a string")
  assert(type(Value) == "string", "crypt.derive: expected argument #1 to be a string")
  
  local Out = ""
  local Counter = 1

  while #Out < Length do
    Out ..= Serde.hash("sha256", Value .. Counter)
    Counter += 1
  end

  return Out:sub(1, Length)
end

function Library.hash(Text : string, Algorithm : string): string
  assert(type(Text) == "string", "crypt.hash: expected argument #1 to be a string, got " .. type(Text))
  assert(Algorithm == nil or type(Algorithm) == "string", "crypt.hash: expected argument #2 to be a string, got " .. type(Algorithm))
  Algorithm = Algorithm or "sha384"
  
  local Supported = {
    "md5",
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "sha3-224",
    "sha3-256",
    "sha3-384",
    "sha3-512",
    "blake3"
  }
  
  local Found = false
  for _, Name in Supported do
    if Name == Algorithm then
      Found = true
      break
    end
  end
  
  assert(Found == true, "crypt.hash: argument #2 is not a supported algorithm, got " .. Algorithm)
  return Serde.hash(Algorithm, Text)
end

function Library.encrypt(Text : string, Key : string, IV : string?): string
  assert(type(Text) == "string", "crypt.encrypt: expected argument #1 to be a string, got " .. type(Text))
  assert(type(Key) == "string", "crypt.encrypt: expected argument #2 to be a string, got " .. type(Key))
  
  local BlockSize = #Key
  IV = IV or string.rep("\0", BlockSize)
  
  assert(#IV == BlockSize, "crypt.encrypt: Intialization Vector must match BlockSize")
  
  Text = Pad(Text, BlockSize)
  
  local Encrypted, Previous = {}, IV
  for i = 1, #Text, BlockSize do
    local Block = Text:sub(i, i + BlockSize - 1)
    if BlockSize > #Block then
      Block ..= string.rep("\0", BlockSize - #Block)
    end
    
    local Xored = Xor(Block, Previous)
    local CipherBlock = Xor(Xored, Key)
    table.insert(Encrypted, CipherBlock)
    
    Previous = CipherBlock
  end
  
  return table.concat(Encrypted), IV
end

function Library.decrypt(Text : string, Key : string, IV : string?): string
  assert(type(Text) == "string", "crypt.decrypt: expected argument #1 to be a string, got " .. type(Text))
  assert(type(Key) == "string", "crypt.decrypt: expected argument #2 to be a string, got " .. type(Key))
  
  local BlockSize = #Key
  IV = IV or string.rep("\0", BlockSize)
  
  assert(#IV == BlockSize, "crypt.encrypt: Intialization Vector must match BlockSize")
  
  local Decrypted, Previous = {}, IV
  
  for i = 1, #Text, BlockSize do
    local Block = Text:sub(i, i + BlockSize - 1)
    local Xored = Xor(Block, Key)
    local PlainBlock = Xor(Xored, Previous)
    table.insert(Decrypted, PlainBlock)
    
    Previous = Block
  end
  
  return Unpad(table.concat(Decrypted))
end

return Library